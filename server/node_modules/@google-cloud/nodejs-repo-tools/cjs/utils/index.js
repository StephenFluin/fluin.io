/**
 * Copyright 2017, Google, Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

require('colors');

var childProcess = require('child_process');
var got = require('got');
var net = require('net');
var url = require('url');

var _require = require('child_process'),
    spawn = _require.spawn;

var MAX_TRIES = 8;

exports.parseArgs = function () {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (Array.isArray(args)) {
    return args;
  }

  var parsed = [];
  var arg = '';
  var inQuote = false;
  var quoteChar = null;

  for (var i = 0; i < args.length; i++) {
    if (args[i] === `'`) {
      if (inQuote) {
        if (args[i - 1] === `\\`) {
          arg += args[i];
        } else {
          if (quoteChar === `'`) {
            arg += args[i];
            inQuote = false;
            quoteChar = null;
          } else {
            arg += args[i];
          }
        }
      } else {
        if (args[i - 1] === `\\`) {
          arg += args[i];
        } else {
          arg += args[i];
          quoteChar = `'`;
          inQuote = true;
        }
      }
    } else if (args[i] === `"`) {
      if (inQuote) {
        if (args[i - 1] === `\\`) {
          arg += args[i];
        } else {
          if (quoteChar === `"`) {
            arg += args[i];
            inQuote = false;
            quoteChar = null;
          } else {
            arg += args[i];
          }
        }
      } else {
        if (args[i - 1] === `\\`) {
          arg += args[i];
        } else {
          arg += args[i];
          quoteChar = `"`;
          inQuote = true;
        }
      }
    } else if (/\s/.test(args[i])) {
      if (inQuote) {
        arg += args[i];
      } else if (arg) {
        parsed.push(arg);
        arg = ``;
      } else {
        args = ``;
      }
    } else {
      arg += args[i];
    }

    if (i === args.length - 1) {
      if (inQuote) {
        throw new Error(`Unclosed quote in: ${args}`);
      } else if (arg) {
        parsed.push(arg);
      }
    }
  }

  return parsed;
};

exports.getUrl = function (opts) {
  return `https://${opts.version}-dot-${opts.project}.appspot.com`;
};

exports.finalize = function (err, resolve, reject) {
  if (err) {
    reject(err);
  } else {
    resolve();
  }
};

var logger = {
  error(config) {
    var _console;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // eslint-disable-next-line no-console
    (_console = console).error.apply(_console, [`${(typeof config === 'string' ? config : config.test).bold.red}:`].concat(_toConsumableArray(args.map(function (arg) {
      if (arg.red) {
        return arg.red;
      }
      return arg;
    }))));
  },

  fatal() {
    this.error.apply(this, arguments);
    // eslint-disable-next-line no-process-exit
    process.exit(1);
  },

  log(config) {
    var _console2;

    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    // eslint-disable-next-line no-console
    (_console2 = console).log.apply(_console2, [`${(typeof config === 'string' ? config : config.test).bold}:`].concat(args));
  },

  debug() {
    if (process.argv.indexOf('--debug') !== -1) {
      var _console3;

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      // eslint-disable-next-line no-console
      (_console3 = console).log.apply(_console3, ['debug'.bold].concat(args));
    }
  }
};

exports.logger = logger;

exports.getRepoPath = function (repository, cwd) {
  repository || (repository = {});
  if (typeof repository === 'string') {
    repository = {
      url: repository
    };
  }

  if (!repository.url) {
    var pushUrl = childProcess.execSync('git remote get-url --push origin', {
      cwd,
      stdout: 'silent'
    }).toString().trim();
    var start = pushUrl.indexOf('github.com');
    if (start >= 0) {
      pushUrl = pushUrl.substring(start + 11);
      if (pushUrl) {
        return `/${pushUrl.replace('.git', '')}`;
      }
    }
  }

  var result = url.parse(repository.url).path.replace('.git', '');
  if (!result.startsWith('/')) {
    return `/${result}`;
  }
  return result;
};

exports.getTimeTaken = function (start) {
  var timeTaken = (Date.now() - start) / 1000;
  if (timeTaken <= 100) {
    timeTaken = timeTaken.toPrecision(3);
  } else if (timeTaken >= 100) {
    timeTaken = Math.floor(timeTaken);
  }
  return `${timeTaken}s`.cyan;
};

/**
 * Generates a markdown badge for displaying a "Release Quality'.
 *
 * @param {string} releaseQuality One of: (ga, beta, alpha, eap, deprecated).
 * @returns {string} The markdown badge.
 */
exports.createReleaseQualityBadge = function (releaseQuality) {
  releaseQuality = releaseQuality.toUpperCase();
  var badge = '';
  if (releaseQuality === 'GA') {
    badge = 'general%20availability%20%28GA%29-brightgreen';
  } else if (releaseQuality === 'BETA') {
    badge = 'beta-yellow';
  } else if (releaseQuality === 'ALPHA') {
    badge = 'alpha-orange';
  } else if (releaseQuality === 'EAP') {
    badge = 'EAP-yellow';
  } else if (releaseQuality === 'DEPRECATED') {
    badge = 'deprecated-red';
  } else {
    logger.error('generate', `Expected "release_quality" to be one of: (ga, beta, alpha, eap, deprecated)! Actual: "${releaseQuality}"`);
    // eslint-disable-next-line no-process-exit
    process.exit(1);
  }
  return `[![release level](https://img.shields.io/badge/release%20level-${badge}.svg?style=flat)](https://cloud.google.com/terms/launch-stages)`;
};

var portrange = 45032;
var triedPorts = {};

exports.getPort = function (config) {
  var port = config.port || portrange;

  while (triedPorts[port]) {
    port += 1;
  }

  triedPorts[port] = true;

  return new Promise(function (resolve) {
    var server = net.createServer();
    server.listen(port, function () {
      server.once('close', function () {
        resolve(port);
      });
      server.close();
    });
    server.on('error', function () {
      resolve(exports.getPort(config));
    });
  });
};

exports.testRequest = function (url, config, numTry) {
  logger.log('app', `Verifying: ${url.yellow}`);
  if (!numTry) {
    numTry = 1;
  }

  var canTryAgain = false;

  return got(url, {
    timeout: 10000
  }).then(function (response) {
    var EXPECTED_STATUS_CODE = config.code || 200;

    var body = response.body || '';
    var code = response.statusCode;

    if (code !== EXPECTED_STATUS_CODE) {
      canTryAgain = true;
      throw new Error(`failed verification!\nExpected status code: ${EXPECTED_STATUS_CODE}\nActual: ${code}`);
    } else if (config.msg && !body.includes(config.msg)) {
      throw new Error(`failed verification!\nExpected body: ${config.msg}\nActual: ${body}`);
    } else if (config.testStr && !config.testStr.test(body)) {
      throw new Error(`failed verification!\nExpected body: ${config.testStr}\nActual: ${body}`);
    }
  }, function (err) {
    canTryAgain = true;
    if (err && err.response) {
      var EXPECTED_STATUS_CODE = config.code || 200;

      var body = err.response.body || '';
      var code = err.response.statusCode;

      if (code !== EXPECTED_STATUS_CODE) {
        throw new Error(`failed verification!\nExpected status code: ${EXPECTED_STATUS_CODE}\nActual: ${code}`);
      } else if (config.msg && !body.includes(config.msg)) {
        throw new Error(`failed verification!\nExpected body: ${config.msg}\nActual: ${body}`);
      } else if (config.testStr && !config.testStr.test(body)) {
        throw new Error(`failed verification!\nExpected body: ${config.testStr}\nActual: ${body}`);
      }
    } else {
      return Promise.reject(err);
    }
  }).catch(function (err) {
    if (numTry >= MAX_TRIES || !canTryAgain) {
      return Promise.reject(err);
    }

    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        exports.testRequest(url, config, numTry + 1).then(resolve, reject);
      }, 500 * Math.pow(numTry, 2));
    });
  });
};

// Delete an App Engine version
exports.deleteVersion = function (config) {
  return new Promise(function (resolve, reject) {
    var cmd = config.deleteCmd || 'gcloud';

    logger.log(config, 'Deleting deployment...');
    // Keep track off whether "done" has been called yet
    var calledDone = false;

    var args = [`app`, `versions`, `delete`, config.test, `--project=${config.projectId}`, `-q`];

    var child = spawn(cmd, args, {
      cwd: config.cwd,
      // Shouldn't take more than 4 minutes to delete a deployed version
      timeout: 4 * 60 * 1000
    });

    logger.log(config, `Delete command: ${(cmd + ' ' + args.join(' ')).yellow}`);

    child.on('error', finish);

    child.stdout.on('data', function (data) {
      var str = data.toString();
      if (str.includes('\n')) {
        process.stdout.write(`${config.test.bold}: ${str}`);
      } else {
        process.stdout.write(str);
      }
    });
    child.stderr.on('data', function (data) {
      var str = data.toString();
      if (str.includes('\n')) {
        process.stderr.write(`${config.test.bold}: ${str}`);
      } else {
        process.stderr.write(str);
      }
    });

    child.on('exit', function (code) {
      if (code !== 0) {
        finish(new Error(`${config.test}: failed to delete deployment!`));
      } else {
        finish();
      }
    });

    // Exit helper so we don't call "cb" more than once
    function finish(err) {
      if (!calledDone) {
        calledDone = true;
        exports.finalize(err, resolve, reject);
      }
    }
  });
};