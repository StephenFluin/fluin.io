/**
 * Copyright 2017, Google, Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

require('colors');

var _ = require('lodash');
var execSync = require('child_process').execSync;
var fs = require('fs-extra');
var handlebars = require('handlebars');
var path = require('path');
var string = require('string');

var buildPack = require('../../build_packs').getBuildPack();
var options = require('../options');
var products = require('../../utils/products');
var utils = require('../../utils');

var CLI_CMD = 'generate';

handlebars.registerHelper('slugify', function (str) {
  return string(str).slugify().s;
});
handlebars.registerHelper('trim', function (str) {
  return string(str).trim().s;
});
handlebars.registerHelper('release_quality', utils.createReleaseQualityBadge);
handlebars.registerHelper('if_eq', function (left, right, opts) {
  if (left === right) {
    return opts.fn(undefined);
  }
  return opts.inverse(undefined);
});
handlebars.registerHelper('syntax_highlighting_ext', function (opts) {
  var repoPath = path.parse(opts.data.root.repoPath).name.replace('google', '').replace('cloud', '');
  if (repoPath.includes('csharp') || repoPath.includes('dotnet')) {
    return 'cs';
  } else if (repoPath.includes('go')) {
    return 'go';
  } else if (repoPath.includes('java')) {
    return 'java';
  } else if (repoPath.includes('node')) {
    return 'javascript';
  } else if (repoPath.includes('php')) {
    return 'php';
  } else if (repoPath.includes('python')) {
    return 'python';
  } else if (repoPath.includes('ruby')) {
    return 'ruby';
  }
  return '';
});

function gatherHelpText(opts, buildPack) {
  (buildPack.config.samples || []).forEach(function (sample) {
    if (typeof sample.usage === 'string') {
      sample.usage = {
        cmd: sample.usage,
        text: sample.usage
      };
    }
    if (!sample.help && sample.usage && typeof sample.usage.cmd === 'string') {
      try {
        sample.help = execSync(sample.usage.cmd, {
          cwd: opts.localPath
        }).toString().trim();
      } catch (err) {
        utils.logger.error(CLI_CMD, err.message);
        // eslint-disable-next-line no-process-exit
        process.exit(err.status);
      }
    }
  });
}

function expandOpts(opts, buildPack) {
  opts.samples || (opts.samples = []);
  gatherHelpText(opts, buildPack);
}

var RE_REGION_TAG_START = /\[START ([\w_-]+)\]/g;
var RE_REGION_TAG_END = /\[END ([\w_-]+)\]/g;

function getQuickstart(filename) {
  if (!path.isAbsolute(filename)) {
    filename = path.join(buildPack._cwd, filename);
  }
  var regionTag = 'quickstart';
  try {
    regionTag = buildPack.config.generate.lib_readme.quickstart_region_tag || 'quickstart';
  } catch (err) {
    // Ignore error
  }
  var content = fs.readFileSync(filename, 'utf-8');
  var lines = content.split('\n');
  var inRegion = false;
  var firstIdx = -1;
  var lastIdx = -1;

  lines.forEach(function (line, i) {
    if (!inRegion) {
      var matches = line.match(RE_REGION_TAG_START);
      if (matches && matches[0] && matches[0].indexOf(regionTag) !== -1) {
        inRegion = true;
        if (firstIdx === -1) {
          firstIdx = i + 1;
        }
      }
    } else {
      var _matches = line.match(RE_REGION_TAG_END);
      if (_matches && _matches[0] && _matches[0].indexOf(regionTag) !== -1) {
        inRegion = false;
        if (lastIdx === -1) {
          lastIdx = i;
        }
      }
    }
  });

  return lines.slice(firstIdx, lastIdx).join('\n');
}

var TARGETS = buildPack.config.generate;
var availableTargetsStr = '';
Object.keys(TARGETS).forEach(function (target) {
  availableTargetsStr += `  ${target.yellow}:  ${TARGETS[target].description}\n`;
});

var COMMAND = `tools ${CLI_CMD} <targets..> ${'[options]'.yellow}`;
var DESCRIPTION = `Generate the given target(s) in ${buildPack._cwd.yellow}.`;

var USAGE = `Usage:
  ${COMMAND.bold}
Description:
  ${DESCRIPTION}

${'Available targets:'.bold}

${availableTargetsStr}`;

exports.command = `${CLI_CMD} <targets..>`;
exports.description = DESCRIPTION;

exports.builder = function (yargs) {
  yargs.usage(USAGE).options({
    config: options.config,
    'config-key': options.configKey,
    data: {
      description: `${'Default:'.bold} ${`{}`.yellow}. JSON string, to be passed to the template.`,
      requiresArg: true,
      type: 'string'
    },
    except: {
      description: `Exclude targets when using the ${'all'.bold} target.`,
      requiresArg: true,
      type: 'array'
    }
  });
};

exports.handler = function (opts) {
  if (opts.dryRun) {
    utils.logger.log(CLI_CMD, 'Beginning dry run.'.cyan);
  }

  if (opts.targets.indexOf('all') !== -1) {
    // Generate all targets
    opts.targets = Object.keys(TARGETS);
    opts.targets.splice(opts.targets.indexOf('all'), 1);
    opts.targets.splice(opts.targets.indexOf('lib_samples_readme'), 1);
    opts.targets.splice(opts.targets.indexOf('samples_readme'), 1);
    if (Array.isArray(opts.except)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = opts.except[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var exception = _step.value;

          if (opts.targets.indexOf(exception) !== -1) {
            opts.targets.splice(opts.targets.indexOf(exception), 1);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }

  buildPack.expandConfig(opts);
  utils.logger.log(CLI_CMD, `Generating ${opts.targets.join(', ')} in: ${opts.localPath.yellow}`);

  // The badgeUri is used for test status badges
  opts.repoPath = utils.getRepoPath(opts.repository, opts.localPath) || null;
  buildPack.config.cloudBuildBadgeUri = path.join('cloud-docs-samples-badges', opts.repoPath, opts.name);

  // Load associated product information, if any
  if (buildPack.config.product) {
    try {
      Object.keys(products[buildPack.config.product]).forEach(function (field) {
        buildPack.config[field] = products[buildPack.config.product][field];
      });
    } catch (err) {
      utils.logger.error(CLI_CMD, `Unrecognized product: ${buildPack.config.product}`);
      return;
    }
  }

  var start = Date.now();
  var errors = [];

  // Generate each specified target
  opts.targets.forEach(function (target) {
    var targetConfig = TARGETS[target];
    var targetPath = path.join(opts.localPath, targetConfig.filename);
    utils.logger.log(CLI_CMD, 'Compiling:', targetPath.yellow);

    try {
      if (target === 'lib_samples_readme' || target === 'samples_readme') {
        // Prepare config for the samples, if any
        expandOpts(opts, buildPack);
      }

      // Prepare the data for the template
      var data = _.merge(opts, targetConfig.data || {}, buildPack.config);
      data.lib_pkg_name = buildPack.config.generate.lib_readme.getLibPkgName(buildPack);
      // Other data prep
      if (target === 'lib_readme') {
        if (buildPack.config.generate.lib_readme.quickstart_filename) {
          data.quickstart = getQuickstart(path.join(opts.localPath, buildPack.config.generate.lib_readme.quickstart_filename), buildPack);
        }
        data.lib_install_cmd = buildPack.config.generate.lib_readme.lib_install_cmd.replace('{{name}}', data.lib_pkg_name);
      }

      // Load the target's template
      var tpl = void 0;
      try {
        tpl = fs.readFileSync(path.join(__dirname, `../../../templates/${opts.buildPack}/${target}.tpl`), 'utf-8');
      } catch (err) {
        tpl = fs.readFileSync(path.join(__dirname, `../../../templates/${target}.tpl`), 'utf-8');
      }
      // Validate the data for the given target is sufficient
      if (targetConfig.validate) {
        targetConfig.validate(data);
      }
      if (targetConfig.addData) {
        targetConfig.addData(data, opts);
      }

      // Generate the content
      var generated = handlebars.compile(tpl)(data);

      if (opts.dryRun) {
        utils.logger.log(CLI_CMD, `Printing: ${targetPath.yellow}\n${generated}`);
        return;
      }

      fs.ensureDir(path.parse(targetPath).dir, function (err) {
        if (err) {
          utils.logger.error(CLI_CMD, err.stack || err.message);
          // eslint-disable-next-line no-process-exit
          process.exit(1);
        }

        // Write the content to the target's filename
        fs.writeFile(targetPath, generated, function (err) {
          if (err) {
            utils.logger.error(CLI_CMD, err.stack || err.message);
            // eslint-disable-next-line no-process-exit
            process.exit(1);
          }

          utils.logger.log(CLI_CMD, `Generated: ${targetPath}`.green);
        });
      });
    } catch (err) {
      errors.push(err);
      utils.logger.error(CLI_CMD, `Failed to generate: ${targetPath}`.red);
    }
  });

  var timeTakenStr = utils.getTimeTaken(start);

  if (errors.length) {
    utils.logger.error(CLI_CMD, `Oh no! Generating failed after ${timeTakenStr}.`);
    errors.forEach(function (error) {
      utils.logger.error(CLI_CMD, error);
    });
  } else {
    utils.logger.log(CLI_CMD, `Success! Generating finished in ${timeTakenStr}.`.green);
  }
};