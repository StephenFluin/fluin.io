/**
 * Copyright 2017, Google, Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

require('colors');

var fs = require('fs');
var path = require('path');

exports.command = 'unify';
exports.description = '(Node.js only) Recursively add sub-directory dependencies to the top-level package.json file.';

exports.builder = function (yargs) {
  yargs.options({
    localPath: {
      alias: 'l',
      default: process.cwd(),
      requiresArg: true,
      type: 'string'
    }
  });
};

exports.handler = function (opts) {
  // Dedupe package.json dependencies
  // WARNING: This will fail if two different versions of the same package are required.
  var pkgSet = {};

  function getDeps(directory, depth) {
    // Limit recursion depth
    if (depth < 0) {
      return;
    }

    // Skip module directories
    if (directory.includes('/.') || directory.includes('node_modules')) {
      return;
    }

    // Get subdirectories
    var dirs = fs.readdirSync(directory);

    // Record subdirectories that contain a package.json file
    var pkgJson = void 0;
    var pkgJsonDirs = dirs.filter(function (dir) {
      return fs.existsSync(path.join(directory, dir, `package.json`));
    });
    pkgJsonDirs.forEach(function (dir) {
      pkgJson = JSON.parse(fs.readFileSync(path.join(directory, dir, `package.json`)));
      Object.assign(pkgSet, pkgJson.dependencies);
    });

    // Recurse
    var recurseDirs = dirs.filter(function (dir) {
      return fs.statSync(path.join(directory, dir)).isDirectory();
    });
    recurseDirs.forEach(function (dir) {
      getDeps(path.join(directory, dir), depth - 1);
    });
  }

  getDeps(opts.localPath, 3);

  // Update root-level package.json (by shelling to npm)
  var spawn = require('child_process').spawn;
  var args = [`add`, `-D`].concat(Object.keys(pkgSet).map(function (pkg) {
    return `${pkg}@${pkgSet[pkg]}`;
  }));
  spawn(`yarn`, args, {
    cwd: opts.localPath,
    shell: true,
    stdio: ['ignore', process.stdout, process.stderr]
  });
};